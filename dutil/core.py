"""Solveit basic helpers"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['setup_dialog', 'solveit_version', 'in_dialog', 'get_caller_globals', 'next_dup', 'next_filename', 'gen_id', 'at_',
           'setup_ns', 'info', 'add_info', 'summarize', 'get_output', 'get_tag', 'link_msg', 'get_tool_names',
           'show_tool_names', 'add_tools_card', 'empty_dialog_nb', 'find_symbol_msg', 'importdlg']

# %% ../nbs/00_core.ipynb
import re
import sys
import inspect
import time
import uuid
from collections import defaultdict
from pathlib import Path
from typing import Any, Mapping
import fastcore.all as FC
import dialoghelper
from dialoghelper.core import _find_frame_dict, add_msg, mk_toollist, find_msg_id, is_usable_tool, read_msg, find_var, update_msg, find_msgs, msg_idx, run_msg, toggle_header, ast_py
from fastgit import Git

# %% ../nbs/00_core.ipynb
def solveit_version():
    "Return the version of solveit if it is found"
    s = ' '.join(_.__module__ for _ in sys.meta_path)
    mtch = re.match(r'.*__editable___solveit_(\d+)_(\d+)_(\d+)_finder', s)
    return f"{mtch[1]}.{mtch[2]}.{mtch[3]}" if mtch else ''

# %% ../nbs/00_core.ipynb
def in_dialog():
    "Check if the code is running in a solveit dialog"
    return bool(solveit_version() and dialoghelper.find_dname() and dialoghelper.find_msg_id())

# %% ../nbs/00_core.ipynb
def get_caller_globals(): 
    "Return the globals of the caller"
    return inspect.currentframe().f_back.f_globals

# %% ../nbs/00_core.ipynb
def next_dup(fp, marker='_dup'):
    "Get next available duplicate number in fp parent directory"
    fp = Path(fp)
    p, nm, suff = fp.parent, fp.stem.split('.')[0], ''.join(fp.suffixes)
    nm = m[1] if (m := re.match(r'^(.+)'+re.escape(marker)+r'\d+$', nm)) else nm
    # if not p.exists(): i, p/f"{nm}{marker}{i}{suff}"
    dupr = re.compile(r'^'+re.escape(nm+marker)+r'(\d+)$')
    nums = sorted({int(m[1]) for f in p.iterdir() if (m := re.match(dupr, f.stem.split('.')[0]))})
    # if not nums: return 0, p/f"{nm}{suff}"
    for i,n in enumerate(nums, 1):
        if i != n: return i, p/f"{nm}{marker}{i}{suff}"
    return len(nums)+1, p/f"{nm}{marker}{len(nums)+1}{suff}"



# %% ../nbs/00_core.ipynb
def next_filename(path:str):
    "Get next available duplicate filename for path, e.g., 'img.jpg' -> 'img_dup1.jpg'"
    _,fp = next_dup(Path(path))
    return str(fp)

# %% ../nbs/00_core.ipynb
def gen_id(): return f"_{uuid.uuid4().hex[:8]}"

# %% ../nbs/00_core.ipynb
_empty = inspect.Parameter.empty

# %% ../nbs/00_core.ipynb
def at_(
    o, # Object to traverse (dict, list, object, or nested combination)
    sym: str, # Path using dots and/or brackets (e.g., 'a.b[0].c' or 'a[b][c]')",
    default: Any=_empty, # Value to return if path not found (raises exception if not provided)
    sep='.' # Separator for path segments
) -> Any: # Value at the specified path
    "Traverse nested `o` using path `sym` with dot notation and/or bracket indexing"
    sym = re.sub(r'\[([^\]]+)\]', r'.\1', sym)
    try:
        for a in filter(None, sym.split(sep)):
            if a.lstrip('-').isdigit(): a = int(a)
            try: o = o[a]
            except Exception:
                if isinstance(a, int):
                    try: o = o[str(a)]; continue
                    except Exception: pass
                o = getattr(o, a)
    except Exception:
        if default is not _empty: return default
        raise
    return o

# %% ../nbs/00_core.ipynb
def setup_ns(ns=None, **kwargs):
    "Add `kwargs` to the namespace `ns` or current dialog"
    ns = ns or _find_frame_dict('__msg_id')
    # lc = list(locals().items())[1:]
    thisid = find_msg_id()
    for k,v in kwargs.items(): ns[k] = v
    msgid = link_msg('\n\n'.join(f"{k} = {v}" for k,v in kwargs.items()))
    print(thisid, msgid)

setup_dialog = setup_ns

# %% ../nbs/00_core.ipynb
def info():
    "Returns information about the dialog"
    ver = f"""Solveit version: **{solveit_version()}**  
dialoghelper version: **{dialoghelper.__version__}**  
"""
    gs = ''
    g = Git('.')
    if g.exists:
        br, *chngs = g('status', '-bs')
        gs = f"""git branch: **{br.split()[-1]}**  
git changes: {chngs}  
"""
    return ver + gs

# %% ../nbs/00_core.ipynb
def add_info(msgid:str=''):
    "Add a message with information about the dialog"
    return link_msg(info(), id=msgid)

# %% ../nbs/00_core.ipynb
def summarize(target, context): pass

# %% ../nbs/00_core.ipynb
FC.delegates(read_msg)
def get_output(id:str=None, **kwargs) -> list[str]:
    msg = read_msg(0, id=id or find_msg_id())
    return msg.output

# %% ../nbs/00_core.ipynb
_ts, _te = ('<!-- ', '#| '), (' -->', '')
def get_tag(name:str, msgid:str='', msg_type:str='note'):
    return f"{_ts[msg_type=='code']}{name}: {msgid or find_msg_id()}{_te[msg_type=='code']}"

# %% ../nbs/00_core.ipynb
get_ipython().xpush(__linked_msgs={})  # WARNING: neither get_ipython (in user_ns) nor ipykernel_helper.xpush is documented

# %% ../nbs/00_core.ipynb
@FC.delegates(add_msg)
def link_msg(
    content:str=None,  # Content of the linked message
    id:str=None,  # ID of the message to link to, or current message if not provided
    **kwargs  # Additional keyword arguments for `add_msg` or `update_msg`
    ):  # id of linked message
    "Add or update a message linked to `anchor` message. Note only one linked msg per anchor."
    anchor_id, linked = id or find_msg_id(), find_var('__linked_msgs')
    if linked_id := linked.get(anchor_id):
        if 'msg' not in (msg := read_msg(0, True, linked_id)):
            tag = get_tag('linkedto', anchor_id, kwargs.get('msg_type', msg.msg_type))
            if content: kwargs['content'] = f"{tag}\n{content}"
            linked[anchor_id] = update_msg(linked_id, **kwargs)
            return linked[anchor_id]
    tag = get_tag('linkedto', anchor_id, kwargs.get('msg_type', 'note'))
    linked[anchor_id] = add_msg(f"{tag}\n{content or ''}", id=anchor_id, **kwargs)
    return linked[anchor_id]

# %% ../nbs/00_core.ipynb
def get_tool_names(
    ns:Mapping=None,  # module or mapping; None uses IPython user namespace
    exclude:Mapping|list[str]=None,  # module/mapping (recursively scanned) or list of symbol names to exclude
    only_exported:bool=False,  # if ns is a module, only include symbols in __all__
    exclude_private:bool=True  # exclude symbols starting with '_'
) -> dict[str,list[str]]:  # module name -> list of tool names
    "Return dict mapping module names to lists of usable tool names from namespace ns (or IPython user namespace if None)."
    exports = set(getattr(ns, '__all__', []))
    if inspect.ismodule(ns): ns = vars(ns)
    if not ns: ns = get_ipython().user_ns
    if exclude: exclude = set(sum(get_tool_names(exclude).values(), []) if not FC.is_listy(exclude) else exclude)
    res = defaultdict(list)
    for k,v in ns.items():
        if exclude_private and k[0] == '_': continue
        if only_exported and k not in exports: continue
        if exclude and k in exclude: continue
        if not hasattr(__builtins__, k) and callable(v):
            try:
                if is_usable_tool(v): 
                    if inspect.isclass(v) and '__call__' not in v.__dict__: continue
                    res[getattr(v, '__module__', 'unknown')].append(k)
            except Exception: pass
    return dict(res)

# %% ../nbs/00_core.ipynb
FC.delegates(get_tool_names)
def show_tool_names(*args, **kwargs):
    for mn,syms in get_tool_names(*args, **kwargs).items():
        print(mn)
        print('  ', ', '.join(syms))

# %% ../nbs/00_core.ipynb
def add_tools_card(ns=None):
    "Add a message with all tools in namespace `ns` or caller globals"
    ns = ns or get_ipython().user_ns
    mod2tool = get_tool_names(ns)
    content = '\n\n'.join(f"## {mod}\n\n{mk_toollist(ns[t] for t in tools)}" for mod,tools in mod2tool.items())
    link_msg(content)

# %% ../nbs/00_core.ipynb
def empty_dialog_nb() -> str:
    "Return a minimal dialog notebook json"
    return '''
{
"cells": [],
"metadata": {
"solveit_dialog_mode": "learning",
"solveit_ver": 2
},
"nbformat": 4,
"nbformat_minor": 5
}
'''

# %% ../nbs/00_core.ipynb
def find_symbol_msg(
    dname: str,  # dialog to look symbol for; default to current dialog
    sym: str  # symbol name
) -> dict:
    "Find last message in dname containing symbol definition (at module level)"
    msgs = find_msgs(dname=dname, include_meta=True)
    for m in reversed(msgs):
        if m.msg_type != 'code': continue
        root = ast_py(m.content)
        for node in root.find_all(pattern='def $FUNC($$$)'):
            if node.field('name').text() == sym: return m
        for node in root.find_all(pattern='class $CLASS'):
            if node.field('name').text() == sym: return m
        for node in root.find_all(pattern='$VAR = $$$'):
            if node.field('left').text() == sym: return m
    return None

# %% ../nbs/00_core.ipynb
def importdlg(dname:str='', syms:list[str]=None, ids:list[str]=None, re_include:str=None, re_exclude:str=None, run:bool=False, header:bool=False, heading_collapsed:bool=False):
    "Import by symbols, ids, regex filter, or all messages"
    msg_ids,to_import,seen = [],[],set()
    if syms or ids:
        if syms:
            for sym in syms:
                m = find_symbol_msg(dname, sym)
                if m and m.id not in seen: to_import.append(m); seen.add(m.id)
        if ids:
            msgs = find_msgs(dname=dname, include_meta=True, include_output=True)
            for m in msgs:
                if m.id in ids and m.id not in seen: to_import.append(m); seen.add(m.id)
        to_import.sort(key=lambda m: msg_idx(m.id, dname))
        for m in to_import: msg_ids.append(add_msg(m.content, msg_type=m.msg_type, output=m.output, time_run=m.time_run, is_exported=m.is_exported, skipped=m.skipped, pinned=m.pinned, i_collapsed=m.i_collapsed, o_collapsed=m.o_collapsed, heading_collapsed=m.heading_collapsed))
    else:
        msgs = find_msgs(dname=dname, include_meta=True, include_output=True)
        if re_include: msgs = [m for m in msgs if re.search(re_include, m.content + m.output, re.MULTILINE | re.DOTALL)]
        if re_exclude: msgs = [m for m in msgs if not re.search(re_exclude, m.content + m.output, re.MULTILINE | re.DOTALL)]
        for m in msgs:
            if m.id not in seen: msg_ids.append(add_msg(m.content, msg_type=m.msg_type, output=m.output, time_run=m.time_run, is_exported=m.is_exported, skipped=m.skipped, pinned=m.pinned, i_collapsed=m.i_collapsed, o_collapsed=m.o_collapsed, heading_collapsed=m.heading_collapsed)); seen.add(m.id)
    if header and msg_ids: 
        hdrid = add_msg(f"## Imported from {dname}", placement='add_before', id=msg_ids[0])
        msg_ids.insert(0, hdrid)
        msg_ids.append(add_msg("## ----", id=msg_ids[-1]))
    time.sleep(0.5)
    if run and msg_ids: run_msg(','.join(msg_ids))
    time.sleep(0.1)
    if heading_collapsed and header: toggle_header(hdrid)
    return msg_ids
