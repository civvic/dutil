"""Solveit basic helpers"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto #0
__all__ = ['setup_dialog', 'solveit_version', 'in_dialog', 'get_caller_globals', 'next_dup', 'next_filename', 'gen_id', 'at_',
           'setup_ns', 'info', 'add_info', 'summarize', 'get_output', 'get_tag', 'link_msg', 'get_tool_names',
           'show_tool_names', 'add_tools_card', 'empty_dialog_nb', 'find_symbol_msg', 'importdlg']

# %% ../nbs/00_core.ipynb #e72f67fd
import re
import sys
import inspect
import time
import uuid
from collections import defaultdict
from pathlib import Path
from typing import Any, Mapping
import fastcore.all as FC
import dialoghelper
from dialoghelper.core import _find_frame_dict, add_msg, mk_toollist, find_msg_id, is_usable_tool, read_msg, find_var, update_msg, find_msgs, msg_idx, run_msg, toggle_header, ast_py
from fastgit import Git

# %% ../nbs/00_core.ipynb #6389d58d
def solveit_version():
    "Return the version of solveit if it is found"
    s = ' '.join(_.__module__ for _ in sys.meta_path)
    mtch = re.match(r'.*__editable___solveit_(\d+)_(\d+)_(\d+)_finder', s)
    return f"{mtch[1]}.{mtch[2]}.{mtch[3]}" if mtch else ''

# %% ../nbs/00_core.ipynb #85a58913
def in_dialog():
    "Check if the code is running in a solveit dialog"
    return bool(solveit_version() and dialoghelper.find_dname() and dialoghelper.find_msg_id())

# %% ../nbs/00_core.ipynb #a0c6cf33
def get_caller_globals(): 
    "Return the globals of the caller"
    return inspect.currentframe().f_back.f_globals

# %% ../nbs/00_core.ipynb #cc011438
def next_dup(fp, marker='_dup'):
    "Get next available duplicate number in fp parent directory"
    fp = Path(fp)
    p, nm, suff = fp.parent, fp.stem.split('.')[0], ''.join(fp.suffixes)
    nm = m[1] if (m := re.match(r'^(.+)'+re.escape(marker)+r'\d+$', nm)) else nm
    # if not p.exists(): i, p/f"{nm}{marker}{i}{suff}"
    dupr = re.compile(r'^'+re.escape(nm+marker)+r'(\d+)$')
    nums = sorted({int(m[1]) for f in p.iterdir() if (m := re.match(dupr, f.stem.split('.')[0]))})
    # if not nums: return 0, p/f"{nm}{suff}"
    for i,n in enumerate(nums, 1):
        if i != n: return i, p/f"{nm}{marker}{i}{suff}"
    return len(nums)+1, p/f"{nm}{marker}{len(nums)+1}{suff}"



# %% ../nbs/00_core.ipynb #9ec1c746
def next_filename(path:str):
    "Get next available duplicate filename for path, e.g., 'img.jpg' -> 'img_dup1.jpg'"
    _,fp = next_dup(Path(path))
    return str(fp)

# %% ../nbs/00_core.ipynb #a537ff31
def gen_id(): return f"_{uuid.uuid4().hex[:8]}"

# %% ../nbs/00_core.ipynb #5a3f523f
_empty = inspect.Parameter.empty

# %% ../nbs/00_core.ipynb #f300a22f
def at_(
    o, # Object to traverse (dict, list, object, or nested combination)
    sym: str, # Path using dots and/or brackets (e.g., 'a.b[0].c' or 'a[b][c]')",
    default: Any=_empty, # Value to return if path not found (raises exception if not provided)
    sep='.' # Separator for path segments
) -> Any: # Value at the specified path
    "Traverse nested `o` using path `sym` with dot notation and/or bracket indexing"
    sym = re.sub(r'\[([^\]]+)\]', r'.\1', sym)
    try:
        for a in filter(None, sym.split(sep)):
            if a.lstrip('-').isdigit(): a = int(a)
            try: o = o[a]
            except Exception:
                if isinstance(a, int):
                    try: o = o[str(a)]; continue
                    except Exception: pass
                o = getattr(o, a)
    except Exception:
        if default is not _empty: return default
        raise
    return o

# %% ../nbs/00_core.ipynb #60e5b6e0
def setup_ns(ns=None, **kwargs):
    "Add `kwargs` to the namespace `ns` or current dialog"
    ns = ns or _find_frame_dict('__msg_id')
    # lc = list(locals().items())[1:]
    thisid = find_msg_id()
    for k,v in kwargs.items(): ns[k] = v
    msgid = link_msg('\n\n'.join(f"{k} = {v}" for k,v in kwargs.items()))
    print(thisid, msgid)

setup_dialog = setup_ns

# %% ../nbs/00_core.ipynb #64bf2039
def info():
    "Returns information about the dialog"
    ver = f"""Solveit version: **{solveit_version()}**  
dialoghelper version: **{dialoghelper.__version__}**  
"""
    gs = ''
    g = Git('.')
    if g.exists:
        br, *chngs = g('status', '-bs')
        gs = f"""git branch: **{br.split()[-1]}**  
git changes: {chngs}  
"""
    return ver + gs

# %% ../nbs/00_core.ipynb #e2bc850b
def add_info(msgid:str=''):
    "Add a message with information about the dialog"
    return link_msg(info(), id=msgid)

# %% ../nbs/00_core.ipynb #8e88bb43
def summarize(target, context): pass

# %% ../nbs/00_core.ipynb #1fb709a6
FC.delegates(read_msg)
def get_output(id:str=None, **kwargs) -> list[str]:
    msg = read_msg(0, id=id or find_msg_id())
    return msg.output

# %% ../nbs/00_core.ipynb #1e17ec9b
_ts, _te = ('<!-- ', '#| '), (' -->', '')
def get_tag(name:str, msgid:str='', msg_type:str='note'):
    return f"{_ts[msg_type=='code']}{name}: {msgid or find_msg_id()}{_te[msg_type=='code']}"

# %% ../nbs/00_core.ipynb #f1bcd921
get_ipython().xpush(__linked_msgs={})  # WARNING: neither get_ipython (in user_ns) nor ipykernel_helper.xpush is documented

# %% ../nbs/00_core.ipynb #44ea9ed5
@FC.delegates(add_msg)
def link_msg(
    content:str=None,  # Content of the linked message
    id:str=None,  # ID of the message to link to, or current message if not provided
    **kwargs  # Additional keyword arguments for `add_msg` or `update_msg`
    ):  # id of linked message
    "Add or update a message linked to `anchor` message. Note only one linked msg per anchor."
    anchor_id, linked = id or find_msg_id(), find_var('__linked_msgs')
    if linked_id := linked.get(anchor_id):
        if 'msg' not in (msg := read_msg(0, True, linked_id)):
            tag = get_tag('linkedto', anchor_id, kwargs.get('msg_type', msg.msg_type))
            if content: kwargs['content'] = f"{tag}\n{content}"
            linked[anchor_id] = update_msg(linked_id, **kwargs)
            return linked[anchor_id]
    tag = get_tag('linkedto', anchor_id, kwargs.get('msg_type', 'note'))
    linked[anchor_id] = add_msg(f"{tag}\n{content or ''}", id=anchor_id, **kwargs)
    return linked[anchor_id]

# %% ../nbs/00_core.ipynb #2f133f3b
def get_tool_names(
    ns:Mapping=None,  # module or mapping; None uses IPython user namespace
    exclude:Mapping|list[str]=None,  # module/mapping (recursively scanned) or list of symbol names to exclude
    only_exported:bool=False,  # if ns is a module, only include symbols in __all__
    exclude_private:bool=True  # exclude symbols starting with '_'
) -> dict[str,list[str]]:  # module name -> list of tool names
    "Return dict mapping module names to lists of usable tool names from namespace ns (or IPython user namespace if None)."
    exports = set(getattr(ns, '__all__', []))
    if inspect.ismodule(ns): ns = vars(ns)
    if not ns: ns = get_ipython().user_ns
    if exclude: exclude = set(sum(get_tool_names(exclude).values(), []) if not FC.is_listy(exclude) else exclude)
    res = defaultdict(list)
    for k,v in ns.items():
        if exclude_private and k[0] == '_': continue
        if only_exported and k not in exports: continue
        if exclude and k in exclude: continue
        if not hasattr(__builtins__, k) and callable(v):
            try:
                if is_usable_tool(v): 
                    if inspect.isclass(v) and '__call__' not in v.__dict__: continue
                    res[getattr(v, '__module__', 'unknown')].append(k)
            except Exception: pass
    return dict(res)

# %% ../nbs/00_core.ipynb #c7389abd
FC.delegates(get_tool_names)
def show_tool_names(*args, **kwargs):
    for mn,syms in get_tool_names(*args, **kwargs).items():
        print(mn)
        print('  ', ', '.join(syms))

# %% ../nbs/00_core.ipynb #7fca2fc7
@FC.delegates(get_tool_names)
def add_tools_card(ns:Mapping=None, **kwargs):
    "Add a message with all tools in namespace `ns` or caller globals"
    ns = ns or get_ipython().user_ns
    mod2tool = get_tool_names(ns, **kwargs)
    content = '\n\n'.join(f"## {mod}\n\n{mk_toollist(getattr(ns, t) if inspect.ismodule(ns) else ns[t] for t in tools)}" for mod,tools in mod2tool.items())
    link_msg(content)

# %% ../nbs/00_core.ipynb #0f89451e
def empty_dialog_nb() -> str:
    "Return a minimal dialog notebook json"
    return '''
{
"cells": [],
"metadata": {
"solveit_dialog_mode": "learning",
"solveit_ver": 2
},
"nbformat": 4,
"nbformat_minor": 5
}
'''

# %% ../nbs/00_core.ipynb #a96b3c40
def _r(m:dict, **kwargs):
    "Add kwargs to m and filter out key/value not compatible with add_msg or update_msg"
    if kwargs: m.update(kwargs)
    if m.msg_type == 'code': m.output = ''
    return dict(content=m.content, msg_type=m.msg_type, output=m.output, is_exported=m.is_exported, skipped=m.skipped, pinned=m.pinned, i_collapsed=m.i_collapsed, o_collapsed=m.o_collapsed, heading_collapsed=m.heading_collapsed)

# %% ../nbs/00_core.ipynb #aea4f976
def find_symbol_msg(msgs, sym:str) -> dict|None:
    "Find last message in msgs list containing symbol definition (module level)"
    for m in reversed(msgs):
        if m.msg_type != 'code': continue
        root = ast_py(m.content)
        for node in root.find_all(pattern='def $FUNC($$$)'):
            if node.field('name').text() == sym: return m
        for node in root.find_all(pattern='class $CLASS'):
            if node.field('name').text() == sym: return m
        for node in root.find_all(pattern='$VAR = $$$'):
            if node.field('left').text() == sym: return m
    return None

# %% ../nbs/00_core.ipynb #6524b978
def importdlg(
    dname:str='',  # dialog to import from; relative to solveit root (if starts with /) or current dialog; empty string for current dialog
    syms:list[str]=None,  # symbol names to import (finds last def/class/assignment); if provided, regex is ignored
    ids:list[str]=None,  # message ids to import; can combine with syms; if syms or ids provided, regex is ignored
    re_include:str=None,  # regex to filter messages (content+output); only used if no syms/ids; uses re.MULTILINE|re.DOTALL
    re_exclude:str=None,  # regex to exclude from re_include results; only used if no syms/ids
    run:bool=False,  # run imported messages after insertion
    header:bool=False,  # wrap imports in collapsed header with dialog name
    heading_collapsed:bool=False  # collapse the header after creation
):
    "Import messages from dname by symbols, ids, regex filter, or all messages; inserts below current message in original order"
    msgs, to_import = find_msgs(dname=dname, include_meta=True, include_output=True), []
    if not dname: msgs = msgs[:msg_idx(find_msg_id())]
    if syms or ids:
        id2idx, seen = {m.id:i for i,m in enumerate(msgs)}, set()
        if syms:
            for sym in syms:
                if (m := find_symbol_msg(msgs, sym)) and m.id not in seen: to_import.append(m); seen.add(m.id)
        if ids:
            for m in msgs:
                if m.id in ids and m.id not in seen: to_import.append(m); seen.add(m.id)
        to_import.sort(key=lambda m: id2idx[m.id])
    else:
        to_import = msgs
        if re_include: to_import = [m for m in to_import if re.search(re_include, m.content + m.output, re.MULTILINE | re.DOTALL)]
        if re_exclude: to_import = [m for m in to_import if not re.search(re_exclude, m.content + m.output, re.MULTILINE | re.DOTALL)]
    new_ids = [add_msg(**_r(m)) for m in to_import]
    if header and new_ids: 
        hdrid = add_msg(f"## Imported from {dname}", placement='add_before', id=new_ids[0])
        new_ids.insert(0, hdrid)
        new_ids.append(add_msg("## ----", id=new_ids[-1]))
    time.sleep(0.5)
    if run and new_ids: run_msg(','.join(new_ids))
    time.sleep(0.1)
    if heading_collapsed and header: toggle_header(hdrid)
    return new_ids
