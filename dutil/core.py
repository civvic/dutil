"""Solveit basic helpers"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['setup_dialog', 'solveit_version', 'in_dialog', 'get_caller_globals', 'gen_id', 'at_', 'get_tool_names',
           'add_tools_card', 'get_output', 'get_tag', 'link_msg', 'setup_ns', 'info', 'add_info', 'summarize']

# %% ../nbs/00_core.ipynb
import re
import sys
import inspect
import uuid
from typing import Any
import fastcore.all as FC
from fastcore.xtras import is_listy
import dialoghelper
from dialoghelper.core import _find_frame_dict, add_msg, mk_toollist, find_msg_id, is_usable_tool, read_msg, find_var, update_msg
from fastgit import Git

# %% ../nbs/00_core.ipynb
def solveit_version():
    "Return the version of solveit if it is found"
    s = ' '.join(_.__module__ for _ in sys.meta_path)
    mtch = re.match(r'.*__editable___solveit_(\d+)_(\d+)_(\d+)_finder', s)
    return f"{mtch[1]}.{mtch[2]}.{mtch[3]}" if mtch else ''

# %% ../nbs/00_core.ipynb
def in_dialog():
    "Check if the code is running in a solveit dialog"
    return bool(solveit_version() and dialoghelper.find_dname() and dialoghelper.find_msg_id())

# %% ../nbs/00_core.ipynb
def get_caller_globals(): 
    "Return the globals of the caller"
    return inspect.currentframe().f_back.f_globals

# %% ../nbs/00_core.ipynb
def gen_id(): return f"_{uuid.uuid4().hex[:8]}"

# %% ../nbs/00_core.ipynb
_empty = inspect.Parameter.empty

# %% ../nbs/00_core.ipynb
def at_(
    o, # Object to traverse (dict, list, object, or nested combination)
    sym: str, # Path using dots and/or brackets (e.g., 'a.b[0].c' or 'a[b][c]')",
    default: Any=_empty, # Value to return if path not found (raises exception if not provided)
    sep='.' # Separator for path segments
) -> Any: # Value at the specified path
    "Traverse nested `o` using path `sym` with dot notation and/or bracket indexing"
    sym = re.sub(r'\[([^\]]+)\]', r'.\1', sym)
    try:
        for a in filter(None, sym.split(sep)):
            if a.lstrip('-').isdigit(): a = int(a)
            try: o = o[a]
            except Exception:
                if isinstance(a, int):
                    try: o = o[str(a)]; continue
                    except Exception: pass
                o = getattr(o, a)
    except Exception:
        if default is not _empty: return default
        raise
    return o

# %% ../nbs/00_core.ipynb
def get_tool_names(ns=None, exclude=None, only_exported=False, exclude_private=True):
    "Return the names of all tools in namespace `ns` or current dialog."
    ns = ns or _find_frame_dict('__msg_id')
    exports = set(getattr(ns, '__all__', []))
    if exclude: exclude = set(get_tool_names(exclude) if not is_listy(exclude) else exclude)
    if inspect.ismodule(ns): ns = vars(ns)
    for k,v in ns.items():
        if exclude_private and k[0] == '_': continue
        if only_exported and k not in exports: continue
        if exclude and k in exclude: continue
        if not hasattr(__builtins__, k) and callable(v):
            try: 
                if is_usable_tool(v): yield k
            except Exception: pass

# %% ../nbs/00_core.ipynb
def add_tools_card(ns=None):
    "Add a message with all tools in namespace `ns` or caller globals"
    ns = ns or _find_frame_dict('__msg_id')
    add_msg(mk_toollist(ns[_] for _ in get_tool_names(ns)))

# %% ../nbs/00_core.ipynb
FC.delegates(read_msg)
def get_output(msgid:str=None, at:str='', **kwargs) -> list[str]:
    msg, p = read_msg(0, id=msgid or find_msg_id()), f"output.{at}" if at else 'output'
    return at_(msg, p, default=None)

# %% ../nbs/00_core.ipynb
_ts, _te = ('<!-- ', '#| '), (' -->', '')
def get_tag(name:str, msgid:str='', msg_type:str='note'):
    return f"{_ts[msg_type=='code']}{name}: {msgid or find_msg_id()}{_te[msg_type=='code']}"

# %% ../nbs/00_core.ipynb
get_ipython().xpush(__linked_msgs={})  # WARNING: neither get_ipython (in user_ns) nor ipykernel_helper.xpush is documented

# %% ../nbs/00_core.ipynb
@FC.delegates(add_msg)
def link_msg(
    content:str=None,  # Content of the linked message
    id:str=None,  # ID of the message to link to, or current message if not provided
    **kwargs  # Additional keyword arguments for `add_msg` or `update_msg`
    ):  # id of linked message
    "Add or update a message linked to `anchor` message. Note only one linked msg per anchor."
    anchor_id, linked = id or find_msg_id(), find_var('__linked_msgs')
    if linked_id := linked.get(anchor_id):
        if 'msg' not in (msg := read_msg(0, True, linked_id)):
            tag = get_tag('linkedto', anchor_id, kwargs.get('msg_type', msg.msg_type))
            if content: kwargs['content'] = f"{tag}\n{content}"
            linked[anchor_id] = update_msg(linked_id, **kwargs)
            return linked[anchor_id]
    tag = get_tag('linkedto', anchor_id, kwargs.get('msg_type', 'note'))
    linked[anchor_id] = add_msg(f"{tag}\n{content or ''}", id=anchor_id, **kwargs)
    return linked[anchor_id]

# %% ../nbs/00_core.ipynb
def setup_ns(ns=None, **kwargs):
    "Add `kwargs` to the namespace `ns` or current dialog"
    ns = ns or _find_frame_dict('__msg_id')
    # lc = list(locals().items())[1:]
    thisid = find_msg_id()
    for k,v in kwargs.items(): ns[k] = v
    msgid = link_msg('\n\n'.join(f"{k} = {v}" for k,v in kwargs.items()))
    print(thisid, msgid)

setup_dialog = setup_ns

# %% ../nbs/00_core.ipynb
def info():
    "Returns information about the dialog"
    ver = f'''Solveit version: **{solveit_version()}**  
dialoghelper version: **{dialoghelper.__version__}**  
'''
    gs = ''
    g = Git('.')
    if g.exists:
        br, *chngs = g('status', '-bs')
        gs = f'''git branch: **{br.split()[-1]}**  
git changes: {chngs}  
'''
    return ver + gs

# %% ../nbs/00_core.ipynb
def add_info(msgid:str=''):
    "Add a message with information about the dialog"
    return link_msg(info(), id=msgid)

# %% ../nbs/00_core.ipynb
def summarize(target, context): pass
